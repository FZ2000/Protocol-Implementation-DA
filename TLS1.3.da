"""
The Transport Layer Security (TLS) Protocol Version 1.3

Source: E. Rescorla
"RFC-8446 - The Transport Layer Security (TLS) Protocol Version 1.3" 
August 2018

Implemented by Frank Zhou

TLS handshake diagram (RFC 8446 p.11)
1. Client to Server: ClientHello
2. Server to Client: ServerHello
3. Server to Client: Certificate, 
4. Server to Client: Signature 
5. Server to Client: Finished
6. Client to Server: Finished

"""
from sa.secalgo import *
from sa.sec_algo_pycrypto import *
from Crypto.Hash import SHA256
import time

Protocol_VERSION12 = '0x0303'

# Signature algorithms
# RSASSA-PKCS1-v1_5 algorithms 
rsa_pkcs1_sha256 = '0x0401'
rsa_pkcs1_sha384 = '0x0501'
rsa_pkcs1_sha512 = '0x0601'

# Cipher Suites (Page 133)
TLS_AES_128_GCM_SHA256 = ('0x13','0x01')
TLS_AES_256_GCM_SHA384 = ('0x13','0x02')
TLS_CHACHA20_POLY1305_SHA256 = ('0x13','0x03') 
TLS_AES_128_CCM_SHA256 = ('0x13','0x04')
TLS_AES_128_CCM_8_SHA256 = ('0x13','0x05')

# Enum Message ID (Not part of the original paper)
CLIENTHELLO = 0
SERVERHELLO = 1
SERVERCERTIFICATE = 2
SERVERCERTIFICATEVERIFY = 3
SERVERFINISHED = 4
CLIENTFINISHED = 5

# Extension is a new concept in TLS 1.3. I use a class to handle it.
# (Page 37)
class Extensions(object):
    def __init__(self,
                 server_name = None, 
                 max_fragment_legth = None,
                 status_request = None,
                 supported_groups = None,
                 signature_algorithms = None,
                 use_srtp = None,
                 heartbeat = None,
                 application_layer_protocol_negotiation = None,
                 signed_certificate_timestamp = None,
                 client_certifacate_type = None,
                 server_certificate_type = None,
                 padding = None,
                 key_share = None,
                 pre_shared_key = None,
                 psk_key_exchange_modes = None,
                 early_data = None,
                 cookie = None,
                 supported_versions = None,
                 certificate_authorities = None,
                 old_filters = None,
                 post_hanndshake_auth = None,
                 signature_algorithm_cert = None):
        self.server_name = server_name 
        self.max_fragment_legth = max_fragment_legth
        self.status_request = status_request 
        self.supported_groups = supported_groups,
        self.signature_algorithms = signature_algorithms,
        self.use_srtp = use_srtp,
        self.heartbeat = heartbeat,
        self.application_layer_protocol_negotiation = application_layer_protocol_negotiation,
        self.signed_certificate_timestamp = signed_certificate_timestamp,
        self.client_certifacate_type = client_certifacate_type,
        self.server_certificate_type = server_certificate_type,
        self.padding = padding,
        self.key_share = key_share,
        self.pre_shared_key = pre_shared_key,
        self.psk_key_exchange_modes = psk_key_exchange_modes,
        self.early_data = early_data,
        self.cookie = cookie,
        self.supported_versions = supported_versions,
        self.certificate_authorities = certificate_authorities,
        self.old_filters = old_filters,
        self.post_hanndshake_auth = post_hanndshake_auth,
        self.signature_algorithm_cert = signature_algorithm_cert

    def get_all_ext(self):
        return self.__dict__ 

class tls_peer(process): 
    # We use peer here to differentiate server and 
    # What does ce mean
    def setup(peer, secret_key, public_key, certificate_list):
        self.peer = peer
        self.legacy_version = Protocol_VERSION12
        self.cipher_suites = (TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384)
        self.legacy_version_id = (0,)
        self.legacy_compression_method = (0,)
        self.peer = peer
        self.sk = secret_key
        self.pk = public_key
        self.cl = certificate_list

    def initiate_handshake(server):
        # Page 29
        # Random: 32 bytes generated by a secure random number generator.
        client_random = keygen('random', 32)
        
        # Page 50
        # Diffie-Hellman Parameters
        x = int.from_bytes(keygen('random', 16), byteorder = 'little')
        g = modp_groups[5]["g"]
        p = modp_groups[5]["p"]
        e = pow(g,x,p)

        # Page 11
        # Extensions for ClientHello Message 
        client_hello_extentions = Extensions(supported_versions = legacy_version,
                                             key_share = e,
                                             signature_algorithms = rsa_pkcs1_sha256)
        
        # Page 28
        # struct {
        # ProtocolVersion legacy_version = 0x0303;
        # Random random;
        # opaque legacy_session_id<0..32>;
        # CipherSuite cipher_suites<2..2^16-2>;
        # opaque legacy_compression_methods<1..2^8-1>;
        # Extension extensions<8..2^16-1>;
        # } ClientHello;
        # Payload of the client_hello message
        client_hello = (CLIENTHELLO,
                        legacy_version, 
                        client_random, 
                        legacy_version_id, 
                        cipher_suites, 
                        legacy_compression_method, 
                        client_hello_extentions.get_all_ext())
        
        send(client_hello, to = server)
        
        # Receiving Server Hello
        await(some(received((_SERVERHELLO,
                             _legacy_version,
                             server_random,
                             _legacy_version_id,
                             active_cipher_suite, # The cipher suite that will be used
                             _legacy_compression_method,
                             server_hello_extensions), from_ = server)))

        # Record the payload of the ServerHello msg. 
        # Will be used in transcript hash
        server_hello = (SERVERHELLO,
                        legacy_version,
                        server_random,
                        legacy_version_id,
                        active_cipher_suite,
                        legacy_compression_method,
                        server_hello_extensions)

        f = server_hello_extensions["key_share"]
        e = pow(g,x,p) # The Key exchange result

        # Receiving certificate
        await(some(received((SERVERCERTIFICATE, _(0,), server_certificate), 
                                from_ = server)))
        
        server_certificate_msg = (SERVERCERTIFICATE, _(0,), server_certificate)
        server_id = server_certificate[0]
        server_pk = server_certificate[1]

        if verify(((server_id, server_pk), server_certificate[-1]), 
                    key = server_pk):            
            await(some(received((_SERVERCERTIFICATEVERIFY, 
                                server_cert_veri,
                                cert_veri_extensions), from_ = server)))

            veri_msg = (client_hello, 
                        server_hello, 
                        server_certificate)

            if verify((veri_msg, server_cert_veri), 
                    key = server_pk):
                    await(some(received(server_finished, from_ = server)))
            else: 
                print("HandShake Error: ServerCertificateVerify")
        else: 
                print("HandShake Error: ServerCertificate")

    def receive(msg=((_CLIENTHELLO,
                     _Protocol_VERSION12, 
                     client_random, 
                     _legacy_version_id),
                     client_cipher_suites, 
                     _legacy_compression_method
                     client_hello_extentions), from_ = client):
            
            # Record the payload of the ClientHello msg. 
            # Will be used in transcript hash
            client_hello = (Protocol_VERSION12,
                            client_random,
                            legacy_version_id,
                            client_cipher_suites,
                            legacy_compression_method,
                            client_hello_extentions)

            # Page 31
            # random: 32 bytes generated by a secure random number generator.
            server_random = keygen('random', 32)

            # Iterate through the cipher suites
            for cs in client_cipher_suites:
                if cs in cipher_suites:
                    activate_cipher_suites = cs
                    break
            
            signature_algorithms = client_hello_extentions["signature_algorithms"]
            
            # Page 50
            # Diffie-Hellman Parameters        
            e = client_hello_extentions["key_share"]
            y = int.from_bytes(keygen('random', 16), byteorder = 'little')
            g = modp_groups[5]["g"] 
            p = modp_groups[5]["p"]
            f = pow(g,y,p)
            k = pow(e,y,p) # The Key exchange result

            server_hello_extensions = Extensions(supported_versions = Protocol_VERSION12,
                                                 key_share = f)
            # Page 31
            # struct {
            # ProtocolVersion legacy_version = 0x0303;
            # Random random;
            # opaque legacy_session_id_echo<0..32>;
            # CipherSuite cipher_suite;
            # uint8 legacy_compression_method = 0;
            # Extension extensions<6..2^16-1>;
            # } ServerHello;
            # The payload of ServerHello msg                        
            server_hello = (SERVERHELLO,
                            legacy_version,
                            server_random,
                            legacy_version_id,
                            activate_cipher_suites,
                            legacy_compression_method,
                            server_hello_extensions.get_all_ext())

            send(server_hello, to = client)

            # END OF KEY EXCHANGE STAGE
            # START OF AUTHENTICATION STAGE

            # Page 64
            #struct {
            # opaque certificate_request_context<0..2^8-1>;
            # CertificateEntry certificate_list<0..2^24-1>;
            # } Certificate;
            server_certificate_msg = (SERVERCERTIFICATE, (0,), cl[0])

            send(server_certificate_msg, to = client)

            hsh_val = (client_hello, 
                       server_hello, 
                       cl[0])
#######################################################################################
# Need to implement transcript hash here!!!
#######################################################################################
            server_cert_veri = sign(hsh_val, key = sk)
            cert_veri_extensions = Extensions(supported_versions = Protocol_VERSION12,
                                              signature_algorithms_cert = signature_algorithms)
            
            server_cert_veri_msg = (SERVERCERTIFICATEVERIFY, 
                                    server_cert_veri,
                                    cert_veri_extensions)
            send(server_cert_veri_msg, to = client)

            # hsh_val = (client_hello, 
            #            server_hello, 
            #            cl[0],
            #            server_cert_veri)

            # veri_data = ("Finished_Key", sign(hsh_val, key = sk))

            # print(Server: "Finished!")


    def run():
        if peer != None:
            initiate_handshake(peer)
        else:
            if await(False): pass
            elif timeout(10): pass

def main():
    config(channel = 'reliable')
    tls_server = new(TLS_Peer)
    tls_client = new(TLS_Peer)
    
    sk_root, pk_root = keygen('public')
    sk_server, pk_server = keygen('public')
    
    server_certificate = ('server', pk_server,
                          sign(('server', pk_server), key = sk_root))
    root_certificate = ('root', pk_root, sign(('root', pk_root),
                                              key = sk_root))
    certificate_list = (server_certificate, root_certificate)
    
    setup(tls_server, (None, # Peer
                       sk_server, 
                       pk_server,
                       certificate_list))

    setup(tls_client, (tls_server, None, None, None))
   
    start(tls_server)
    start(tls_client)
